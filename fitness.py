# -*- coding: utf-8 -*-
"""
Created on Mon Jul  1 14:01:34 2019

@author: jack
"""
import sys, getopt, math, csv, itertools, os
import numpy as np
from scipy.spatial import distance
from scipy import linalg


class FITNESS(object):
    def __init__(self, physics_engine, experiment, repeat):

        self._physics_engine = physics_engine
        self._experiment = experiment

        self._repeat = repeat

        self._task = 0

    def resetErrors(self,):
        """ reset error values between simulation repeats"""
        #Arm Errors
        self._euclideanResult =0
        self._rotationResult =0
        self._poseResult =0
        self._velocity_error =0
        self._acceleration_error =0
        self._torqueError =0
        self._forceError =0
        self._momentError =0
        #Object Errors
        self._transDiff = 0
        self._rotDiff =0
        self._euclideanObject = 0

    def calculateFitness(self, sim_data, task):#optimisationRun):
        """Calculate the fitness of this simulation based upon data comparisons (this simulation vs ground truth)
        Note this can be modified to target any error below, default is Euclidean Error"""
        # self._optimisationRun = optimisationRun

        self.resetErrors()

        self._task = task
        self._sim = np.asarray(sim_data)#self.readSim()
        self._groundTruth = self.readGroundTruth()
        #Arm Errors
        self._euclideanResult += self.euclideanError()
        # self._rotationResult += self.rotationError()
        # self._poseResult += self.poseError()
        # self._velocity_error += self.velocityError()
        # self._acceleration_error += self.accelerationError()
        # self._torqueError += self.torqueError()
        # self._forceError += self.contactForceError()
        # self._momentError += self.contactMomentError()
        #Object Errors
        if self._task>2:
            # self._transDiff += self.translationDistribution()
            # self._rotDiff += self.rotationDistribution()
            self._euclideanObject += self.euclideanObject()

        fitness =   self._euclideanResult+self._euclideanObject

        return fitness

    def readSim(self,):
        """Read the saved data generated by the current simulation"""

        if self._optimisationRun < 10:
            file = 'Results/%s/experiment%d/Repeat_%d/00%d/task%d.csv'%(self._physics_engine, self._experiment, self._repeat, self._optimisationRun, self._task)
        elif self._optimisationRun < 100:
            file = 'Results/%s/experiment%d/Repeat_%d/0%d/task%d.csv'%(self._physics_engine, self._experiment, self._repeat, self._optimisationRun, self._task)
        else:
            file = 'Results/%s/experiment%d/Repeat_%d/%d/task%d.csv'%(self._physics_engine, self._experiment, self._repeat, self._optimisationRun, self._task)

        my_path = os.path.abspath(os.path.dirname(__file__))
        path = os.path.join(my_path, file)

        np_sim_results = np.genfromtxt(path, comments="#", delimiter=",")
        return np_sim_results


    def readGroundTruth(self,):
        """Read the ground truth data from the csv file, these have been generated via MOCAP and supplied as csv files """
        if self._task == 10:
            file = 'Results/Task10.csv'
        else:
            file = 'Results/Task0'+str(self._task)+'.csv'

        my_path = os.path.abspath(os.path.dirname(__file__))
        path = os.path.join(my_path, file)

        np_data_results = np.genfromtxt(path, comments="#",skip_header=3, delimiter=",")
        np_data_results = np_data_results[2:,:]
        #Make dataset the same length as sim data
        if np_data_results.shape[0] > self._sim.shape[0]:
            np_data_results = np_data_results[0:self._sim.shape[0],:]
        elif np_data_results.shape[0] < self._sim.shape[0]:
            difference  = self._sim.shape[0] - np_data_results.shape[0]
            for row in range(difference):
                np_data_results = np.vstack((np_data_results,np_data_results[-1,:]))
        #Check if last row of dataset has zeros in it
        rows = 1
        row_zero = True
        while row_zero == True:
            row_zero = False
            for col in range(np_data_results.shape[1]):
                if np_data_results[-rows,col] == 0 and col != 13 and col != 14 and col != 15:
                    row_zero = True
                    rows+=1
                    break

        #If zeros then replace with the last rows without zeros
        for row in range(1,rows):
            np_data_results[-(row),:] = np_data_results[-rows,:]

        return np_data_results

    def euclideanError(self,):
        """generate the euclidean error based upon ground truth vs simulation"""
        error = 0
        for step in range(self._sim.shape[0]):
            x_step_error =  (self._sim[step,0]-self._groundTruth[step,0])**2
            y_step_error = (self._sim[step,1]-self._groundTruth[step,1])**2
            z_step_error = (self._sim[step,2]-self._groundTruth[step,2])**2
            step_error = math.sqrt(x_step_error + y_step_error + z_step_error)
            error += step_error
        return error/self._sim.shape[0]

    def rotationError(self,):
        """generate the rotation error based upon ground truth vs simulation"""
        error = 0
        for step in range(self._sim.shape[0]):
            simR = np.array([self._sim[step,3],self._sim[step,4],self._sim[step,5],self._sim[step,6]])
            groundtruthR = np.array([self._groundTruth[step,3],self._groundTruth[step,4],self._groundTruth[step,5],self._groundTruth[step,6]])
            step_error = np.arccos(np.abs(np.dot(simR,groundtruthR)))
            error += step_error
        return error/self._sim.shape[0]

    def poseError(self,):
        """generate the pose error based upon ground truth vs simulation"""
        #Calculated using Park 1995 'Distance Metrics on the Rigid-Body Motions with Applications to Mechanism Design'
        error = 0
        scale = 37 #Rotation has a volume of 8*Pi^2 therefore the workspace volume of the arm should be scaled accordingly. The workspace of the arm is 0.8m
        for step in range(self._sim.shape[0]):
            sim_rotation = RfromQuat(self._sim[step,3],self._sim[step,4],self._sim[step,5],self._sim[step,6])
            dataset_rotation = RfromQuat(self._groundTruth[step,3],self._groundTruth[step,4],self._groundTruth[step,5],self._groundTruth[step,6])
            rotation_error = (np.linalg.norm(linalg.logm(np.linalg.inv(dataset_rotation)*sim_rotation)))**2
            sim_vector = [self._sim[step,0],self._sim[step,1],self._sim[step,2]]
            dataset_vector = [self._groundTruth[step,0],self._groundTruth[step,1],self._groundTruth[step,2]]
            translation_error = (np.linalg.norm(np.subtract(sim_vector,dataset_vector)))**2
            scaled_translation = scale*translation_error
            error+= rotation_error+scaled_translation
        return error/self._sim.shape[0]

    def velocityError(self,):
        """generate the velocity error based upon ground truth vs simulation"""
        frequency = 0.1
        error = 0

        for step in range(self._sim.shape[0]-1):
            current_pos_sim = np.array((self._sim[step+1,0],self._sim[step+1,1],self._sim[step+1,2]))
            past_pos_sim = np.array((self._sim[step,0],self._sim[step,1],self._sim[step,2]))
            dist_sim = distance.euclidean(current_pos_sim, past_pos_sim)
            velocity_sim = dist_sim/frequency

            current_pos_dataset = np.array((self._groundTruth[step+1,0],self._groundTruth[step+1,1],self._groundTruth[step+1,2]))
            past_pos_dataset = np.array((self._groundTruth[step,0],self._groundTruth[step,1],self._groundTruth[step,2]))
            dist_dataset = distance.euclidean(current_pos_dataset, past_pos_dataset)
            velocity_dataset = dist_dataset/frequency

            error +=  abs(velocity_dataset-velocity_sim)
        return error/(self._sim.shape[0]-1)

    def accelerationError(self,):
        """generate the acceleration error based upon ground truth vs simulation"""
        frequency = 0.1
        error = 0

        for step in range(self._sim.shape[0]-2):
            current_pos_sim = np.array((self._sim[step+1,0],self._sim[step+1,1],self._sim[step+1,2]))
            past_pos_sim = np.array((self._sim[step,0],self._sim[step,1],self._sim[step,2]))
            dist_sim = distance.euclidean(current_pos_sim, past_pos_sim)
            past_velocity_sim = dist_sim/frequency

            current_pos_sim = np.array((self._sim[step+2,0],self._sim[step+2,1],self._sim[step+2,2]))
            past_pos_sim = np.array((self._sim[step+1,0],self._sim[step+1,1],self._sim[step+1,2]))
            dist_sim = distance.euclidean(current_pos_sim, past_pos_sim)
            current_velocity_sim = dist_sim/frequency

            acceleration_sim = (past_velocity_sim-current_velocity_sim)/frequency

            current_pos_dataset = np.array((self._groundTruth[step+1,0],self._groundTruth[step+1,1],self._groundTruth[step+1,2]))
            past_pos_dataset = np.array((self._groundTruth[step,0],self._groundTruth[step,1],self._groundTruth[step,2]))
            dist_dataset = distance.euclidean(current_pos_dataset, past_pos_dataset)
            past_velocity_dataset = dist_dataset/frequency

            current_pos_dataset = np.array((self._groundTruth[step+2,0],self._groundTruth[step+2,1],self._groundTruth[step+2,2]))
            past_pos_dataset = np.array((self._groundTruth[step+1,0],self._groundTruth[step+1,1],self._groundTruth[step+1,2]))
            dist_dataset = distance.euclidean(current_pos_dataset, past_pos_dataset)
            current_velocity_dataset = dist_dataset/frequency

            acceleration_dataset = (past_velocity_dataset-current_velocity_dataset)/frequency

            error +=  abs(acceleration_dataset-acceleration_sim)

        return error/(self._sim.shape[0]-2)


    def torqueError(self,):
        """generate the torque error for joint 7-13 based upon ground truth vs simulation"""
        error = 0
        for step in range(1,self._sim.shape[0]):
            torque_sim = 0
            torque_dataset = 0
            for joint in range(7,13):
                torque_sim += abs(self._sim[step,joint])
                torque_dataset += abs(self._groundTruth[step,joint])
            error += abs(torque_dataset-torque_sim)

        return error/(self._sim.shape[0]-1)

    def contactForceError(self,):
        """generate the contact force error based upon ground truth vs simulation"""
        error = 0
        for step in range(self._sim.shape[0]):
            force_sim = 0
            force_dataset = 0
            for axis in range(16,19):
                force_sim += abs(self._sim[step,axis])
                force_dataset += abs(self._groundTruth[step,axis])

            error += abs(force_dataset-force_sim)

        return error/self._sim.shape[0]

    def contactMomentError(self,):
        """generate the contact moment error based upon ground truth vs simulation"""
        error = 0
        for step in range(self._sim.shape[0]):
            moment_sim = 0
            moment_dataset = 0
            for axis in range(19,22):
                moment_sim += abs(self._sim[step,axis])
                moment_dataset += abs(self._groundTruth[step,axis])

            error += abs(moment_dataset-moment_sim)

        return error/self._sim.shape[0]

    def translationDistribution(self,):
        pos_dataset = np.zeros((20,3))

        for repeat in range(0,20):
            col_start = (repeat*7)+22
            pos_dataset[repeat, :] = self._groundTruth[-2,col_start:col_start+3]

        mean_pos_simulation = self._sim[-1,22:25]
        mean_pos_dataset = np.mean(pos_dataset, axis=0)
        cov_pos_dataset = np.cov(np.transpose(pos_dataset))
        inv_cov = distance.mahalanobis(mean_pos_simulation,mean_pos_dataset,linalg.inv(cov_pos_dataset))
        return inv_cov

    def rotationDistribution(self,):
        pos_dataset = np.zeros((20,3))

        for repeat in range(0,20):
            col_start = (repeat*7)+25
            pos_dataset[repeat, :] = EulerfromQuat(self._groundTruth[-2,col_start],self._groundTruth[-2,col_start+1],self._groundTruth[-2,col_start+2],self._groundTruth[-2,col_start+3])

        mean_pos_simulation = EulerfromQuat(self._sim[-1,25],self._sim[-1,26],self._sim[-1,27],self._sim[-1,28])
        mean_pos_dataset = np.mean(pos_dataset, axis=0)
        cov_pos_dataset = np.cov(np.transpose(pos_dataset))
        inv_cov = distance.mahalanobis(mean_pos_simulation,mean_pos_dataset,linalg.inv(cov_pos_dataset))
        return inv_cov

    def euclideanObject(self,):
        pos_dataset = np.zeros((20,3))

        for repeat in range(0,20):
            col_start = (repeat*7)+22
            pos_dataset[repeat, :] = self._groundTruth[-2,col_start:col_start+3]

        mean_pos_simulation = self._sim[-1,22:25]
        mean_pos_dataset = np.mean(pos_dataset, axis=0)
        error = distance.euclidean(mean_pos_simulation, mean_pos_dataset)
        return error

def RfromQuat(w,x,y,z):
    rotMatrix = np.zeros((3,3),np.float64)
    rotMatrix[0][0] = 1 - 2*(y**2) - 2*(z**2)
    rotMatrix[0][1] = 2*x*y - 2*z*w
    rotMatrix[0][2] = 2*x*z + 2*y*w
    rotMatrix[1][0] = 2*x*y + 2*z*w
    rotMatrix[1][1] = 1 - 2*(x**2) - 2*(z**2)
    rotMatrix[1][2] = 2*y*z - 2*x*w
    rotMatrix[2][0] = 2*x*z - 2*y*w
    rotMatrix[2][1] = 2*y*z + 2*x*w
    rotMatrix[2][2] = 1 - 2*(x**2) - 2*(y**2)
    return rotMatrix

def EulerfromQuat(w,x,y,z):
    t0 = 2.0 * (w * x + y * z)
    t1 = 1.0 - 2.0 * (x * x + y * y)
    X = math.degrees(math.atan2(t0, t1))

    t2 = +2.0 * (w * y - z * x)
    t2 = +1.0 if t2 > +1.0 else t2
    t2 = -1.0 if t2 < -1.0 else t2
    Y = math.degrees(math.asin(t2))

    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    Z = math.degrees(math.atan2(t3, t4))

    return np.array((X,Y,Z))